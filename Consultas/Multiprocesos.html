<!DOCTYPE HTML>
<!--
	Alpha by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Aplicaciones Distribuidas 7mo D</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<header id="header">
				<h1><a href="../index.html">Aplicaciones Distribuidas 7mo D</h1>
				<nav id="nav">
					<ul>
						<li><a href="../index.html">Inicio</a></li>
						<li>
							<a href="#" class="icon solid fa-angle-down">Temas</a>
							<ul>
								<li>
									<a href="#">Parcial Uno</a>
									<ul>
										<li><a href="../Temas/HilosSincronizacion.html">Hilos y Sincronización</a></li>
										<li><a href="../Temas/ForkJoin.html">Fork Join</a></li>
										<li><a href="../Temas/StreamParalelas.html">Streams Paralelas</a></li>
										<li><a href="../Temas/JavaStreams.html">Java Streams</a></li>
										<li><a href="../Temas/TcpIp_Sockets.html">TCP/IP Sockets UDP</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Dos</a>
									<ul >
										<li><a href="../Temas/RPC_RMI.html">RPC y RMI</a></li>
										<li><a href="../Temas/VirtualizacionContenedores.html">Virtualización y Cont</a></li>
										<li><a href="../Temas/SpringySpringBoot.html">Spring y SpringBoot</a></li>
										<li><a href="../Temas/SpringWebMVC.html">Spring Web MVC</a></li>
										<li><a href="../Temas/SpringBDD.html">Spring BDD</a></li>
										<li><a href="../Temas/PlantWebSpring.html">Plantillas Web Spring</a></li>
										<li><a href="../Temas/ServWebJMS.html">Servicios Web JMS</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Tres</a>
									<ul>
										<li><a href="../Temas/SistDistArchivos.html">Sistemas Dist de Archivos</a></li>
										<li><a href="../Temas/Hadoop.html">Hadoop</a></li>
										<li><a href="../Temas/Spark.html">Spark</a></li>
										<li><a href="../Temas/MPI_ZeroMQ_NNG.html">MPI, ZeroMQ, NNG</a></li>
										
									</ul>
								</li>
							</ul>
						</li>
						<li>
							<a href="#" class="icon solid fa-angle-down">Consultas</a>
							<ul>
								<li>
									<a href="#">Parcial Uno</a>
									<ul>
										<li><a href="MapReduce.html">Map Reduce</a></li>
										<li><a href="ForkJoin.html">Fork Join</a></li>
										<li><a href="MetodosPorDefecto.html">Metodos por Defecto</a></li>
										<li><a href="ExpLambda.html">Expresión Lambda</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Dos</a>
									<ul>
										<li><a href="MaquinaVirtual.html">Maquina Virtual</a></li>
										<li><a href="VirtualBox.html">Virtual Box</a></li>
										<li><a href="Contenedores.html">Contenedores</a></li>
										<li><a href="Docker.html">Docker</a></li>
										<li><a href="InversionControl.html">Inversión de Control</a></li>
										<li><a href="InyeccionDependencias.html">Inyección Dependencia</a></li>
										<li><a href="ConvencionConfig.html">Convencion Config</a></li>
										<li><a href="MVC.html">MVC</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Tres</a>
									<ul>
										<li><a href="JSP.html">JSP</a></li>
										<li><a href="Thymeleaf.html">Thymeleaf</a></li>
										<li><a href="FreeMarker.html">Freemarker</a></li>
										<li><a href="Groovy.html">Groovy</a></li>																				
									</ul>
								</li>
							</ul>
						</li>
						<!-- <li><a href="#" class="button">Sign Up</a></li> -->
					</ul>
				</nav>
			</header>
			<!-- Main -->
				<section id="main" class="container">
					<header>
						<h2>Multiprocessos</h2>
						
					</header>
					<div class="box">
						<span class="image featured"><img src="images/pic01.jpg" alt="" /></span>
						<h3>Definicion</h3>
						    <p align="justify">El multiprocesamiento, aplicado a la informática, es una forma de operación de una computadora en donde se tiene físicamente más de un procesador. El fin es tener la disposición de ejecutar diferentes partes de un programa a la vez.</p>

                            <p align="justify">Estas múltiples unidades centrales de procesamiento (CPU) se mantienen en una estrecha comunicación, compartiendo el bus, la memoria y otros dispositivos periféricos de la computadora. Dado que hay múltiples procesadores disponibles se pueden ejecutar a la vez múltiples procesos.
                            </p>
                            <div align="center">
                                <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs1.jpg"  width="400" height="270" ><br><br>
                            </div>
                            
						<div class="row">
							<div class="row-6 row-12-mobilep">
								<h3>Características del Multiprocesador</h3>
								    <p align="justify">Permite trabajar con máquinas que poseen más de un microprocesador. En un multiprocesador
                                    Se denomina multiprocesador a un ordenador que cuenta con dos o más microprocesadores (CPUs).
                                    Gracias a esto, el multiprocesador puede ejecutar simultáneamente varios hilos pertenecientes a un mismo proceso o bien a procesos diferentes.
                                    Los ordenadores multiprocesadores presentan problemas de diseño que no se encuentran en ordenadores monoprocesadores. Estos problemas derivan del hecho de que dos programas pueden ejecutarse simultáneamente y, potencialmente, pueden interferirse entre sí. Concretamente, en lo que se refiere a las lecturas y escrituras en memoria. 
                                    </p>
                                    <p align="justify">La arquitectura NUMA, donde cada procesador tiene acceso y control exclusivo a una parte de la memoria. La arquitectura SMP, donde todos los procesadores comparten toda la memoria. Esta última debe lidiar con el problema de la coherencia de caché. Cada microprocesador cuenta con su propia memoria caché local. De manera que cuando un microprocesador escribe en una dirección de memoria, lo hace únicamente sobre su copia local en caché. Si otro microprocesador tiene almacenada la misma dirección de memoria en su caché, resultará que trabaja con una copia obsoleta del dato almacenado.</p>
                                    <p align="justify">Para que un multiprocesador opere correctamente necesita un sistema operativo especialmente diseñado para ello. La mayoría de los sistemas operativos actuales poseen esta capacidad.</p>
                                    <h3>Ejemplos de multiprocesamiento simétrico.</h3>
                                    <p align="justify">Estos sistemas son comunes en dispositivos generales, como ordenadores personales, móviles, tablets, etc. Sin embargo, es en los servidores donde se saca el máximo partido a esta opción y donde podemos encontrar procesadores con hasta 32 núcleos.</p>

                                    <h3>Ejemplos de multiprocesamiento asimétrico.</h3>
                                    <p align="justify">Esta otra opción suele emplearse en sistemas embebidos. En estos casos, hay más de un sistema operativo y cada uno usa sus propias CPU (por ejemplo, un router con un software de enrutamiento propietario en una CPU y con un SO general en la otra). Esta opción permite contar, en un solo equipo, con un router profesional y un servidor que ofrece servicios avanzados.</p>
                                    
                                    <div align="center">
                                        <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs2.jpg"  width="400" height="270" ><br><br>
                                    </div>
							</div><br>
							<div class="row-6 row-12-mobilep">
								<h3>Ejemplos de multiprocesamiento asimétrico.</h3>
                                <p align="justify">Esta otra opción suele emplearse en sistemas embebidos. En estos casos, hay más de un sistema operativo y cada uno usa sus propias CPU (por ejemplo, un router con un software de enrutamiento propietario en una CPU y con un SO general en la otra). Esta opción permite contar, en un solo equipo, con un router profesional y un servidor que ofrece servicios avanzados.</p>
                                <div align="center">
                                    <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs3.jpg"  width="400" height="200" ><br><br>
                                </div>
                                <h3>Arquitectura.</h3>
                                    <p>Un multiprocesador puede verse como un computador paralelo compuesto por varios procesadores interconectados que comparten un mismo sistema de memoria.
                                    Los sistemas multiprocesadores son arquitecturas MIMD con memoria compartida. Tienen un único espacio de direcciones para todos los procesadores y los mecanismos de comunicación se basan en el paso de mensajes desde el punto de vista del programador.
                                    Dado que los multiprocesadores comparten diferentes módulos de memoria, pudiendo acceder a un mismo módulo varios procesadores, a los multiprocesadores también se les llama sistemas de memoria compartida.
                                    Dependiendo de la forma en que los procesadores comparten la memoria, se clasifican en sistemas multiprocesador UMA, NUMA y COMA.
                                    </p>
                                    <div align="center">
                                        <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs4.jpg"  width="400" height="350" ><br><br>
                                    </div>
                                    <h3>Clasificación.</h3>
                                    <p><strong>Uniform memory access. (UMA)</strong></p>
                                    <ul>
                                        <li type="disc">Espacio de direcciones de memoria compartido.</li>
                                        <li type="disc">Tiempo de acceso uniforme para toda dirección.</li>
                                        <li type="disc">Hardware bastante simple.</li>
                                        <li type="disc">El cuello de botella es el acceso a memoria principal, lo cual implica:
                                        </li>
                                        <li type="disc">Grandes cachés en cada procesador</li>
                                        <li type="disc">El número de procesadores no puede ser muy alto. Hoy en día N≤32.</li>
                                    </ul>


                                   
                                    <p><strong>Multiprocesadores muy populares hoy en día:</strong></p>
                                    <ul>
                                        <li type="disc">Todos los SMP’s (Multiprocesadores simétricos con memoria compartida basado en bus común)
                                        </li>
                                        <li type="disc">bi, quad-Pentium.</li>
                                        <li type="disc">Sun Enterprise 10000 (crossbar)</li>
                                    </ul>
                                    <h3>Problema de coherencia en UMA</h3>
                                    <p>El overhead por acceder a la memoria compartida es muy grande. Hay que usar cachés debemos asegurar la coherencia de los datos en dichos dispositivos Cuando usamos un dato privado ⇒ traerlo a caché</p>
                                    <p>Si accedemos a un dato compartido, hay que traerlo a caché, pero si otros procesadores también acceden al dato y se lo llevan a su caché, existirán varias copias distintas del mismo dato. Si algún procesador modifica el dato ⇒ Problema de coherencia.</p>
                                    <h3>Solución</h3>
                                    <p>Intentar evitar las incoherencias mediante hardware.</p>
                                       <p>En UMA se usan protocolos de husmeo (snooping).</p>
                                       <p>Se pueden utilizar gracias a tener un bus único y compartido de comunicación.</p> 
                                        <ul>
                                            <li type="disc">Los controladores de cachés locales espían el bus para ver si circula algún dato de alguna línea que tenga almacenada en su caché</li>
                                            <li type="disc">Los cachés deben de estar provistos de 2 puertos de acceso (p.e. replicando la memoria de etiquetas)</li>
                                            <li type="disc">Uno para el acceso del procesador</li>
                                            <li type="disc">Otro para que el controlador pueda comparar las direcciones que aparecen por el bus<li>                                            
                                        </ul>
                                        <h3>NonUniform memory access(NUMA).</h3>
                                        <ul>
                                            <li type="disc">Espacio de direcciones de memoria compartido
                                            </li>
                                            <li type="disc">Tiempo de acceso no uniforme para toda dirección.</li>
                                            <li type="disc">Depende de si accedemos a la memoria local (no a caché) o a remota.</li>
                                            <li type="disc">Depende de si accedemos a la memoria local (no a caché) o a remota.</li>
                                            <li type="disc">tacc pequeño en accesos a memoria local</li>
                                            <li type="disc">Hard de la red es complejo, necesita redes de interconexión especiales. Existen distintas líneas de comunicación separadas ⇒ mayor AB.</li>
                                            <li type="disc">El problema de la coherencia es más difícil de mantener en hard.</li>
                                        </ul>

                                        <h3>Estos multiprocesadores son escalable</h3>
                                        <p>Escalable: Si crece el número de procesadores N, entonces la memoria crece como orden(N). Esto es gracias a que cada procesador lleva su propia memoria.
                                            Los procesadores UMA no son escalables, puesto que si aumentamos el número de procesadores, la memoria es la misma.
                                            </p>
                                            <h3>Programación y comunicación</h3>
                                            <p>Comunicación entre procesadores es mediante variables globales
                                                Al tener espacio de direcciones de memoria compartida ⇒ Se adapta perfectamente a la programación multihilo (multi-thread)
                                            </p>
                                            <ul>
                                                <li type="disc">Debe existir cacheo de datos remotos en hard, aunque la coherencia sea compleja</li>
                                                <li type="disc">Debe existir soporte hard para el acceso remoto</li>
                                                <li type="disc">Ld local, provoca acceso a caché o memoria local</li>
                                                <li type="disc">Ld remoto, provoca interrupción I/O a la red</li>
                                               
                                            </ul>

                                        <p>Si existe coherencia, el código NUMA es totalmente compatible con UMA. Esto supone una ventaja, puesto que los UMA están muy extendidos y hay muchas aplicaciones desarrolladas. El programador debe tener cuidado con los accesos remotos</p>
                                        <ul>
                                            <li type="disc">Ejemplos: TC2000, KSR-1, Standford Dash, BBN Butterfly, Cray T3D</li>                                         
                                        </ul>
                                        <h3>Solución al problema de coherencia en NUMA.</h3>
                                        <ul>
                                            <li type="disc">La solución hard es más compleja que en UMA</li>
                                            <li type="disc">Han existido máquinas con control de coherencia por software (máquinas NC, NonCoherent). CRAY T3D</li>
                                            <li type="disc">Los datos compartidos se declaran no cacheables</li>
                                            <li type="disc">Si el compilador/programador detecta que un dato compartido será leído muchas veces, y no escrito, realiza un cacheo por software</li>
                                            <li type="disc">Copia el dato en una variable local privada</li>                                            
                                        </ul>
                                        <div align="center">
                                            <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs5.png"  width="400" height="270" ><br><br>
                                        </div>
                                        <h3>Message Passing Machines (MPM).</h3>
                                        <ul>
                                            <li type="disc">Espacio de direcciones de memoria distribuido</li>
                                            <li type="disc">Son compatibles en hard a los NUMA</li>
                                            <li type="disc">Cada procesador es un computador independiente del resto</li>
                                            <li type="disc">Fácilmente escalable</li>                                          
                                        </ul>
                                        <p>El mecanismo de comunicación es a través de mensajes (igual que la comunicación entre procesos del S.O.). No necesita mecanismos hard ni para controlar la coherencia de cachés (pues son espacios distintos de direcciones), ni para implementar los accesos remotos La red es la parte más compleja de escalar</p>
                                        <h3>Programación y comunicación</h3>
                                        <p>Programación orientada a multiprocesos</p>
                                        <P>La comunicación se realiza por mensajes. Existen librerías estándar que:</P>
                                        <ul>
                                            <li type="disc">Realizan la mensajería</li>
                                            <li type="disc">Distribuyen los procesos por las máquinas declaradas del multicomputador.</li>                                           
                                        </ul>
                                        <p>Comunicación explícita, lo cual tiene que ser tenido en cuenta por los programadores. Esto obliga a estar pendiente de ella e intentar ocultar la latencia.</p>
                                        <p>El overhead de comunicación es muy alto, luego interesa enviar datos grandes, p.e. Páginas</p>
                                        <div align="center">
                                            <img style="border:1px solid black;" class="img-fluid" src="../IMAGENES_GRUPO/GRUPO 1/nfs6.jpg"  width="400" height="270" ><br><br>
                                        </div>
                                        <h3>Ventajas</h3>
                                        <ul>
                                            <li type="disc">Este tipo de sistemas tienden a ser más eficientes porque las tareas tanto del sistema operativo como de los usuarios pueden ser distribuidas en forma balanceada a todos los procesadores. </li>
                                            <li type="disc">El tiempo de inactividad de un procesador mientras otro está sobre trabajando es mínimo.</li>
                                            <li type="disc">Si un procesador falla, es posible que sus tareas sean repartidas entre los demás y no es necesario que todo el sistema sea parado o que falle el sistema.</li>
                                            <li type="disc">La portabilidad del sistema es mayor debido a que no sigue la arquitectura mastrer/slave.</li>
                                            <li type="disc">Los sistemas SMP permiten que cualquier procesador trabaje en cualquier tarea sin importar su localización en memoria</li>
                                            <li type="disc">La memoria globalmente compartida también vuelve fácil la sincronización de los datos.</li>
                                            <li type="disc">Muchos procesos pueden ejecutarse simultáneamente (N procesos si hay N CPU) sin que haya deterioro del desempeño. </li>
                                            <li type="disc">Permite comparar dinámicamente trabajos y recursos entre los distintos procesadores, y puede reducir la varianza entre los sistemas</li>
                                        </ul>
                                        <h3>Desventajas</h3>
                                        <ul>
                                            <li type="disc">Conforme se añaden procesadores, el tráfico en el bus de memoria se satura. </li>
                                            <li type="disc">Al manejarse ocho o más procesadores, el cuello de botella se vuelve crítico, inclusive para los mejores diseños, por lo que SMP es considerada una tecnología poco escalable.</li>
                                            <li type="disc">Los sistemas operativos que soportan este tipo de multiprocesamiento son más difíciles de diseñar.</li>
                                            <li type="disc">Dado que las CPU son independientes, una podría estar ociosa mientras otra está sobrecargada, con la consiguienteincidencia</li>                                        
                                        </ul>
							</div>
						</div>
					</div>
				</section>

			<!-- Footer -->
				<footer id="footer">
						<ul class="copyright">
						<li>&copy; Aplicaciones Distribuidas. All rights reserved.</li>
					</ul>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.dropotron.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>